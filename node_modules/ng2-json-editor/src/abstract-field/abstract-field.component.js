/*
 * This file is part of ng2-json-editor.
 * Copyright (C) 2016 CERN.
 *
 * ng2-json-editor is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * ng2-json-editor is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ng2-json-editor; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 * In applying this license, CERN does not
 * waive the privileges and immunities granted to it by virtue of its status
 * as an Intergovernmental Organization or submit itself to any jurisdiction.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { AbstractSubscriberComponent } from '../abstract-subscriber';
/**
 * This is the base class for fields
 * WARNING:
 *  XFieldComponent which extends this class should have all services in this constructor, in their constructor!
 *  EX: constructor(...public appGlobalService: AppGlobalService, ...) {...}
 *
 * It provides trackByFunction from AbstractTrackerComponent, and handles errors for the component.
 */
var AbstractFieldComponent = (function (_super) {
    __extends(AbstractFieldComponent, _super);
    function AbstractFieldComponent(appGlobalsService, problemsService, pathUtilService, changeDetectorRef, jsonStoreService) {
        var _this = _super.call(this) || this;
        _this.appGlobalsService = appGlobalsService;
        _this.problemsService = problemsService;
        _this.pathUtilService = pathUtilService;
        _this.changeDetectorRef = changeDetectorRef;
        _this.jsonStoreService = jsonStoreService;
        _this.pathCache = {};
        _this.externalErrors = [];
        // patches grouped by op because they different UI representation
        _this.replaceJsonPatches = [];
        _this.addJsonPatches = [];
        return _this;
    }
    AbstractFieldComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.problemsService.externalCategorizedProblems$
            .takeUntil(this.isDestroyed)
            .subscribe(function (externalCategorizedProblemMap) {
            _this.externalErrors = externalCategorizedProblemMap.errors[_this.pathString] || [];
            _this.changeDetectorRef.markForCheck();
        });
        this.jsonStoreService.patchesByPath$
            .map(function (patchesByPath) { return patchesByPath[_this.pathString]; })
            .map(function (patches) { return _this.groupJsonPatchesByOp(patches); })
            .takeUntil(this.isDestroyed)
            .subscribe(function (patchesByOp) {
            _this.removeJsonPatch = patchesByOp.remove[0];
            _this.addJsonPatches = patchesByOp.add;
            _this.replaceJsonPatches = patchesByOp.replace;
            _this.changeDetectorRef.markForCheck();
        });
    };
    AbstractFieldComponent.prototype.groupJsonPatchesByOp = function (patches) {
        var group = {
            add: [],
            remove: [],
            replace: []
        };
        if (patches) {
            patches.forEach(function (patch) {
                var opPatches = group[patch.op];
                opPatches.push(patch);
            });
        }
        return group;
    };
    AbstractFieldComponent.prototype.ngOnChanges = function (changes) {
        if (changes['path']) {
            this.pathString = this.pathUtilService.toPathString(this.path);
        }
    };
    /**
     * Gets path for child, returns from `pathCache` if it is a hit
     * in order not to re-render child component due to reference change its path.
     *
     * @param key - index or field name for child
     */
    AbstractFieldComponent.prototype.getPathForChild = function (key) {
        if (!this.pathCache[key] || this.pathCache[key][this.path.length - 1] !== this.path[this.path.length - 1]) {
            this.pathCache[key] = this.path.concat(key);
        }
        return this.pathCache[key];
    };
    AbstractFieldComponent.prototype.hasErrors = function () {
        return this.externalErrors.length > 0;
    };
    Object.defineProperty(AbstractFieldComponent.prototype, "disabled", {
        get: function () {
            return this.schema.disabled && !this.appGlobalsService.adminMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractFieldComponent.prototype, "redLeftBorderClass", {
        get: function () {
            return this.removeJsonPatch ? 'red-left-border' : '';
        },
        enumerable: true,
        configurable: true
    });
    AbstractFieldComponent.prototype.trackByElement = function (index, element) {
        return element;
    };
    AbstractFieldComponent.prototype.trackByIndex = function (index, element) {
        return index;
    };
    return AbstractFieldComponent;
}(AbstractSubscriberComponent));
export { AbstractFieldComponent };
//# sourceMappingURL=abstract-field.component.js.map