{"version":3,"sources":["../../../../staging/src/shared/services/katex.service.ts"],"names":[],"mappings":"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","file":"katex.service.js","sourceRoot":"","sourcesContent":["import { Injectable } from '@angular/core';\nimport { List, Map } from 'immutable';\nimport { render, ParseError } from 'katex';\n\nimport { JSONSchema, KatexData } from '../interfaces';\n\n\nexport class KatexService {\n  private delimiters = [\n    { left: '$$', right: '$$', display: true },\n    { left: '$', right: '$', display: false },\n    // FIXME check if we need the ones below\n    { left: '\\\\[', right: '\\\\]', display: true },\n    { left: '\\\\(', right: '\\\\)', display: false },\n  ];\n\n  /**\n  *\n  * Receives text that can contain LaTeX formulas. The formulas will be\n  * identified using `this.delimiters` and rendered inside the passed\n  * HTMLElement\n  *\n  * NOTE: The HTMLElement is expected to have a single child and this\n  * will be replaced by the HTML with formatted LaTeX\n  *\n  * @param {string} text - text to be formatted with LaTeX\n  * @param {HTMLElement} el - the HTMLElement where the LaTeX should be rendered\n  */\n  renderMathInText(text: string, el: HTMLElement) {\n    const data: Array<KatexData> = this.splitWithDelimiters(text, this.delimiters);\n\n    const fragment = document.createDocumentFragment();\n\n    for (let i = 0; i < data.length; i++) {\n      if (data[i].type === 'text') {\n        fragment.appendChild(document.createTextNode(data[i].data));\n      } else {\n        const span = document.createElement('span');\n        const math = data[i].data;\n        try {\n          render(math, span, {\n            displayMode: data[i].display,\n          });\n        } catch (e) {\n          if (!(e instanceof ParseError)) {\n            throw e;\n          }\n          console.error(\n            `KaTeX auto-render: Failed to parse ${data[i].data} with ${e}`\n          );\n          fragment.appendChild(document.createTextNode(data[i].rawData));\n          continue;\n        }\n        fragment.appendChild(span);\n      }\n    }\n    // clear\n    el.innerHTML = '';\n    el.appendChild(fragment);\n  }\n\n  private findEndOfMath(delimiter: string, text: string, startIndex: number): number {\n    // Adapted from\n    // https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx\n    let index = startIndex;\n    let braceLevel = 0;\n\n    const delimLength = delimiter.length;\n\n    while (index < text.length) {\n      const character = text[index];\n\n      if (braceLevel <= 0 &&\n        text.slice(index, index + delimLength) === delimiter) {\n        return index;\n      } else if (character === '\\\\') {\n        index++;\n      } else if (character === '{') {\n        braceLevel++;\n      } else if (character === '}') {\n        braceLevel--;\n      }\n\n      index++;\n    }\n\n    return -1;\n  }\n\n  private splitAtDelimiters(startData: Array<KatexData>, leftDelim: string, rightDelim: string, display: boolean): Array<KatexData> {\n    const finalData = [];\n\n    for (let i = 0; i < startData.length; i++) {\n      if (startData[i].type === 'text') {\n        const text = startData[i].data;\n\n        let lookingForLeft = true;\n        let currIndex = 0;\n        let nextIndex;\n\n        nextIndex = text.indexOf(leftDelim);\n        if (nextIndex !== -1) {\n          currIndex = nextIndex;\n          finalData.push({\n            type: 'text',\n            data: text.slice(0, currIndex),\n          });\n          lookingForLeft = false;\n        }\n\n        while (true) {\n          if (lookingForLeft) {\n            nextIndex = text.indexOf(leftDelim, currIndex);\n            if (nextIndex === -1) {\n              break;\n            }\n\n            finalData.push({\n              type: 'text',\n              data: text.slice(currIndex, nextIndex),\n            });\n\n            currIndex = nextIndex;\n          } else {\n            nextIndex = this.findEndOfMath(\n              rightDelim,\n              text,\n              currIndex + leftDelim.length);\n            if (nextIndex === -1) {\n              break;\n            }\n\n            finalData.push({\n              type: 'math',\n              data: text.slice(\n                currIndex + leftDelim.length,\n                nextIndex),\n              rawData: text.slice(\n                currIndex,\n                nextIndex + rightDelim.length),\n              display: display,\n            });\n\n            currIndex = nextIndex + rightDelim.length;\n          }\n\n          lookingForLeft = !lookingForLeft;\n        }\n\n        finalData.push({\n          type: 'text',\n          data: text.slice(currIndex),\n        });\n      } else {\n        finalData.push(startData[i]);\n      }\n    }\n\n    return finalData;\n  }\n\n  private splitWithDelimiters(text, delimiters): Array<KatexData> {\n    let data = [{ type: 'text', data: text }];\n    for (let i = 0; i < delimiters.length; i++) {\n      const delimiter = delimiters[i];\n      data = this.splitAtDelimiters(\n        data, delimiter.left, delimiter.right,\n        delimiter.display || false);\n    }\n    return data;\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}