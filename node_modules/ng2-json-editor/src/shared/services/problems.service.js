/*
 * This file is part of ng2-json-editor.
 * Copyright (C) 2017 CERN.
 *
 * ng2-json-editor is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * ng2-json-editor is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ng2-json-editor; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 * In applying this license, CERN does not
 * waive the privileges and immunities granted to it by virtue of its status
 * as an Intergovernmental Organization or submit itself to any jurisdiction.
 */
import { Injectable } from '@angular/core';
import { ReplaySubject } from 'rxjs/ReplaySubject';
import { combineLatest } from 'rxjs/observable/combineLatest';
var ProblemsService = (function () {
    function ProblemsService() {
        this.externalCategorizedProblems$ = new ReplaySubject(1);
        this.internalCategorizedProblems$ = new ReplaySubject(1);
        this.externalProblemCount$ = new ReplaySubject(1);
        this.internalProblemCount$ = new ReplaySubject(1);
        this.errorCount$ = this.getTotalDistinctProblemCount$ForType('errors');
        this.warningCount$ = this.getTotalDistinctProblemCount$ForType('warnings');
        this.internalProblemMap$ = new ReplaySubject(1);
        this.internalProblemMap = {};
        this.internalCategorizedProblemMap = { errors: {}, warnings: {} };
        this.externalCategorizedProblemMap = { errors: {}, warnings: {} };
        this.externalProblemCount = { errors: 0, warnings: 0 };
        this.internalProblemCount = { errors: 0, warnings: 0 };
        // set default counts to components
        this.externalProblemCount$.next(this.externalProblemCount);
        this.internalProblemCount$.next(this.internalProblemCount);
    }
    ProblemsService.prototype.getTotalDistinctProblemCount$ForType = function (type) {
        var external$ = this.externalProblemCount$
            .map(function (counts) { return counts[type]; });
        var internal$ = this.internalProblemCount$
            .map(function (counts) { return counts[type]; });
        return combineLatest(external$, internal$, function (external, internal) { return external + internal; })
            .distinctUntilChanged();
    };
    Object.defineProperty(ProblemsService.prototype, "externalProblems", {
        set: function (problems) {
            var _a = this.categorizeProblemMap(problems), categorizedProblemMap = _a.categorizedProblemMap, errorCount = _a.errorCount, warningCount = _a.warningCount;
            this.externalProblemCount = { errors: errorCount, warnings: warningCount };
            this.externalProblemCount$.next(this.externalProblemCount);
            this.externalCategorizedProblemMap = categorizedProblemMap;
            this.externalCategorizedProblems$.next(this.externalCategorizedProblemMap);
        },
        enumerable: true,
        configurable: true
    });
    ProblemsService.prototype.setInternalProblemsForPath = function (path, problems) {
        this.internalProblemMap[path] = problems;
        this.internalProblemMap$.next(this.internalProblemMap);
        var categorizedProblems = this.categorizeValidationProblems(problems);
        this.internalProblemCount.errors += categorizedProblems.errors.length - this.internalProblemCountForPath(path, 'errors');
        this.internalProblemCount.warnings += categorizedProblems.warnings.length - this.internalProblemCountForPath(path, 'warnings');
        this.internalProblemCount$.next(this.internalProblemCount);
        this.internalCategorizedProblemMap.errors[path] = categorizedProblems.errors;
        this.internalCategorizedProblemMap.warnings[path] = categorizedProblems.warnings;
        this.internalCategorizedProblems$.next(this.internalCategorizedProblemMap);
    };
    ProblemsService.prototype.internalProblemCountForPath = function (path, type) {
        if (this.internalCategorizedProblemMap[type][path]) {
            return this.internalCategorizedProblemMap[type][path].length;
        }
        return 0;
    };
    ProblemsService.prototype.hasProblem = function (path) {
        var internalProblems = this.internalCategorizedProblemMap.errors[path];
        var externalProblems = this.externalCategorizedProblemMap.errors[path];
        var internalProblemCount = internalProblems ? internalProblems.length : 0;
        var externalProblemCount = externalProblems ? externalProblems.length : 0;
        return (internalProblemCount + externalProblemCount) > 0;
    };
    ProblemsService.prototype.categorizeProblemMap = function (problemMap) {
        var _this = this;
        var categorizedProblemMap = { errors: {}, warnings: {} };
        var errorCount = 0;
        var warningCount = 0;
        Object.keys(problemMap)
            .map(function (path) {
            var validationProblems = problemMap[path];
            var categorized = _this.categorizeValidationProblems(validationProblems);
            return { path: path, categorized: categorized };
        }).forEach(function (problemsForPath) {
            categorizedProblemMap.errors[problemsForPath.path] = problemsForPath.categorized.errors;
            categorizedProblemMap.warnings[problemsForPath.path] = problemsForPath.categorized.warnings;
            errorCount += problemsForPath.categorized.errors.length;
            warningCount += problemsForPath.categorized.warnings.length;
        });
        return { categorizedProblemMap: categorizedProblemMap, errorCount: errorCount, warningCount: warningCount };
    };
    ProblemsService.prototype.categorizeValidationProblems = function (validationProblems) {
        var categorized = { errors: [], warnings: [] };
        validationProblems.forEach(function (error) {
            if (error.type === 'Error') {
                categorized.errors.push(error);
            }
            else {
                categorized.warnings.push(error);
            }
        });
        return categorized;
    };
    return ProblemsService;
}());
export { ProblemsService };
ProblemsService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ProblemsService.ctorParameters = function () { return []; };
//# sourceMappingURL=problems.service.js.map